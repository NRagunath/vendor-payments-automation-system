-- Drop tables in reverse order of dependencies
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE AUDIT_LOGS CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE VENDOR_PAYMENT CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE VENDOR CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
/

-- Create VENDOR table with all required columns (Oracle compatible)
CREATE TABLE VENDOR (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    VENDOR_ID VARCHAR2(20) NOT NULL,
    NAME VARCHAR2(100) NOT NULL,
    EMAIL VARCHAR2(100) NOT NULL,
    BANK_ACCOUNT VARCHAR2(50),
    IFSC_CODE VARCHAR2(20),
    BANK_BRANCH VARCHAR2(100),
    PHONE VARCHAR2(20),
    CONTACT_PERSON VARCHAR2(100),
    CONTACT_EMAIL VARCHAR2(100),
    ADDRESS VARCHAR2(255),
    GST_NUMBER VARCHAR2(20),
    PAN_NUMBER VARCHAR2(20),
    STATUS VARCHAR2(20),
    TAX_ID VARCHAR2(50),
    CITY VARCHAR2(100),
    STATE VARCHAR2(100),
    COUNTRY VARCHAR2(100),
    POSTAL_CODE VARCHAR2(20),
    NOTES CLOB,
    ACTIVE NUMBER(1) DEFAULT 1,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UK_VENDOR_ID UNIQUE (VENDOR_ID)
);

-- Create sequence for VENDOR table
CREATE SEQUENCE VENDOR_SEQ START WITH 1 INCREMENT BY 1;

-- Create trigger for VENDOR table
CREATE OR REPLACE TRIGGER VENDOR_BI
BEFORE INSERT ON VENDOR
FOR EACH ROW
BEGIN
    SELECT VENDOR_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
/

-- Create VENDOR_PAYMENT table (Oracle compatible)
CREATE TABLE VENDOR_PAYMENT (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    VENDOR_ID VARCHAR2(20),
    VENDOR_ID_FK NUMBER,
    VENDOR_NAME VARCHAR2(100) NOT NULL,
    VENDOR_EMAIL VARCHAR2(100),
    BANK_ACCOUNT VARCHAR2(50),
    IFSC_CODE VARCHAR2(20),
    REFERENCE_NUMBER VARCHAR2(50),
    INVOICE_NUMBER VARCHAR2(50),
    AMOUNT NUMBER(19,2) NOT NULL,
    PAYMENT_DATE DATE,
    PAYMENT_REFERENCE VARCHAR2(50) NOT NULL,
    STATUS VARCHAR2(20) NOT NULL,
    TRANSACTION_ID VARCHAR2(100),
    BANK_REFERENCE VARCHAR2(50),
    REMARKS CLOB,
    BATCH_PAYMENT_ID NUMBER,
    H2H_PROCESSED NUMBER(1) DEFAULT 0 NOT NULL,
    H2H_PROCESSED_AT TIMESTAMP,
    H2H_REFERENCE VARCHAR2(100),
    H2H_STATUS VARCHAR2(20) DEFAULT 'PENDING',
    H2H_ERROR_MESSAGE CLOB,
    IS_VOID NUMBER(1) DEFAULT 0 NOT NULL,
    DELETION_REASON VARCHAR2(1000),
    RECONCILED_AT TIMESTAMP,
    DELETED_BY NUMBER,
    VOIDED_BY NUMBER,
    CREATED_AT TIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP,
    DELETED_AT TIMESTAMP,
    IS_NOTIFICATION_SENT NUMBER(1) DEFAULT 0 NOT NULL,
    NOTES CLOB,
    BATCH_ID VARCHAR2(50),
    CREATED_BY VARCHAR2(50),
    PAYMENT_CURRENCY VARCHAR2(3),
    CURRENCY VARCHAR2(3),
    IS_RECONCILED NUMBER(1) DEFAULT 0,
    RECONCILIATION_DATE TIMESTAMP,
    RECONCILIATION_REFERENCE VARCHAR2(100),
    INVOICE_DATE DATE,
    COMPLETED_AT TIMESTAMP,
    DESCRIPTION CLOB,
    DUE_DATE DATE,
    ERROR_DETAILS CLOB,
    IS_APPROVED NUMBER(1) DEFAULT 0,
    APPROVED_BY VARCHAR2(50),
    APPROVED_AT TIMESTAMP,
    APPROVAL_NOTES CLOB,
    IS_REJECTED NUMBER(1) DEFAULT 0,
    REJECTED_BY VARCHAR2(50),
    REJECTED_AT TIMESTAMP,
    REJECTION_REASON CLOB,
    IS_EXPORTED NUMBER(1) DEFAULT 0,
    EXPORTED_AT TIMESTAMP,
    EXPORT_REFERENCE VARCHAR2(100),
    IS_REVERSAL NUMBER(1) DEFAULT 0,
    REVERSAL_REASON CLOB,
    CUSTOM_FIELD1 VARCHAR2(255),
    CUSTOM_FIELD2 VARCHAR2(255),
    CUSTOM_FIELD3 VARCHAR2(255),
    CUSTOM_FIELD4 VARCHAR2(255),
    CUSTOM_FIELD5 VARCHAR2(255),
    CONSTRAINT FK_VENDOR_PAYMENT_VENDOR FOREIGN KEY (VENDOR_ID_FK) REFERENCES VENDOR(ID) ON DELETE SET NULL,
    CONSTRAINT FK_VENDOR_PAYMENT_BATCH FOREIGN KEY (BATCH_PAYMENT_ID) REFERENCES BATCH_PAYMENT(ID) ON DELETE SET NULL,
    CONSTRAINT FK_VENDOR_PAYMENT_DELETED_BY FOREIGN KEY (DELETED_BY) REFERENCES APP_USER(ID) ON DELETE SET NULL,
    CONSTRAINT FK_VENDOR_PAYMENT_VOIDED_BY FOREIGN KEY (VOIDED_BY) REFERENCES APP_USER(ID) ON DELETE SET NULL,
    CONSTRAINT UK_PAYMENT_REFERENCE UNIQUE (PAYMENT_REFERENCE)
);

-- Create sequence for VENDOR_PAYMENT table
CREATE SEQUENCE VENDOR_PAYMENT_SEQ START WITH 1 INCREMENT BY 1;

-- Create trigger for VENDOR_PAYMENT table
CREATE OR REPLACE TRIGGER VENDOR_PAYMENT_BI
BEFORE INSERT ON VENDOR_PAYMENT
FOR EACH ROW
BEGIN
    SELECT VENDOR_PAYMENT_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
    IF :NEW.CREATED_AT IS NULL THEN
        :NEW.CREATED_AT := CURRENT_TIMESTAMP;
    END IF;
    IF :NEW.UPDATED_AT IS NULL THEN
        :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
    END IF;
END;
/

-- Create index on frequently queried columns
CREATE INDEX IDX_VENDOR_PAYMENT_REF ON VENDOR_PAYMENT(PAYMENT_REFERENCE);
CREATE INDEX IDX_VENDOR_PAYMENT_STATUS ON VENDOR_PAYMENT(STATUS);
CREATE INDEX IDX_VENDOR_PAYMENT_VENDOR_ID ON VENDOR_PAYMENT(VENDOR_ID_FK);
CREATE INDEX IDX_VENDOR_PAYMENT_BATCH_ID ON VENDOR_PAYMENT(BATCH_PAYMENT_ID);
CREATE INDEX IDX_VENDOR_PAYMENT_CREATED_AT ON VENDOR_PAYMENT(CREATED_AT);
CREATE INDEX IDX_VENDOR_PAYMENT_PAYMENT_DATE ON VENDOR_PAYMENT(PAYMENT_DATE);

-- Indexes for BATCH_PAYMENT
CREATE INDEX IDX_BATCH_PAYMENT_REF ON BATCH_PAYMENT(BATCH_REFERENCE);
CREATE INDEX IDX_BATCH_PAYMENT_STATUS ON BATCH_PAYMENT(STATUS);
CREATE INDEX IDX_BATCH_PAYMENT_CREATED_AT ON BATCH_PAYMENT(CREATED_AT);

-- Indexes for APP_USER
CREATE INDEX IDX_APP_USER_USERNAME ON APP_USER(USERNAME);
CREATE INDEX IDX_APP_USER_EMAIL ON APP_USER(EMAIL);
CREATE INDEX IDX_APP_USER_ACTIVE ON APP_USER(IS_ACTIVE);

-- Create BATCH_PAYMENT table
CREATE TABLE BATCH_PAYMENT (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    BATCH_REFERENCE VARCHAR2(50) NOT NULL,
    DESCRIPTION CLOB,
    TOTAL_AMOUNT NUMBER(19,2) NOT NULL,
    PAYMENT_COUNT NUMBER(10) NOT NULL,
    SUCCESS_COUNT NUMBER(10),
    FAILURE_COUNT NUMBER(10),
    STATUS VARCHAR2(20) NOT NULL,
    CREATED_BY VARCHAR2(50),
    INITIATED_AT TIMESTAMP,
    COMPLETED_AT TIMESTAMP,
    ERROR_MESSAGE CLOB,
    CREATED_AT TIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP,
    CONSTRAINT UK_BATCH_REFERENCE UNIQUE (BATCH_REFERENCE)
);

-- Create sequence for BATCH_PAYMENT table
CREATE SEQUENCE BATCH_PAYMENT_SEQ START WITH 1 INCREMENT BY 1;

-- Create trigger for BATCH_PAYMENT table
CREATE OR REPLACE TRIGGER BATCH_PAYMENT_BI
BEFORE INSERT ON BATCH_PAYMENT
FOR EACH ROW
BEGIN
    SELECT BATCH_PAYMENT_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
    IF :NEW.CREATED_AT IS NULL THEN
        :NEW.CREATED_AT := CURRENT_TIMESTAMP;
    END IF;
    IF :NEW.UPDATED_AT IS NULL THEN
        :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
    END IF;
END;
/

-- Create APP_USER table
CREATE TABLE APP_USER (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    USERNAME VARCHAR2(50) NOT NULL,
    EMAIL VARCHAR2(100) NOT NULL,
    FIRST_NAME VARCHAR2(50),
    LAST_NAME VARCHAR2(50),
    PHONE_NUMBER VARCHAR2(20),
    DEPARTMENT VARCHAR2(100),
    IS_ACTIVE NUMBER(1) DEFAULT 1 NOT NULL,
    LAST_LOGIN TIMESTAMP,
    ROLE VARCHAR2(20),
    CREATED_AT TIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP,
    IS_DELETED NUMBER(1) DEFAULT 0,
    DELETED_AT TIMESTAMP,
    CONSTRAINT UK_USERNAME UNIQUE (USERNAME),
    CONSTRAINT UK_EMAIL UNIQUE (EMAIL)
);

-- Create sequence for APP_USER table
CREATE SEQUENCE APP_USER_SEQ START WITH 1 INCREMENT BY 1;

-- Create trigger for APP_USER table
CREATE OR REPLACE TRIGGER APP_USER_BI
BEFORE INSERT ON APP_USER
FOR EACH ROW
BEGIN
    SELECT APP_USER_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
    IF :NEW.CREATED_AT IS NULL THEN
        :NEW.CREATED_AT := CURRENT_TIMESTAMP;
    END IF;
    IF :NEW.UPDATED_AT IS NULL THEN
        :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
    END IF;
END;
/

-- Create audit log table for tracking changes
CREATE TABLE AUDIT_LOGS (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    ACTION VARCHAR2(50) NOT NULL,
    ENTITY_TYPE VARCHAR2(50) NOT NULL,
    ENTITY_ID VARCHAR2(50),
    USER_ID VARCHAR2(50),
    USER_IP VARCHAR2(50),
    DETAILS CLOB,
    TIMESTAMP TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create sequence for AUDIT_LOGS table
CREATE SEQUENCE AUDIT_LOGS_SEQ START WITH 1 INCREMENT BY 1;

-- Create trigger for AUDIT_LOGS table
CREATE OR REPLACE TRIGGER AUDIT_LOGS_BI
BEFORE INSERT ON AUDIT_LOGS
FOR EACH ROW
BEGIN
    SELECT AUDIT_LOGS_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
/
