package com.shanthigear.mapper;

import com.shanthigear.dto.PaymentRequestDTO;
import com.shanthigear.dto.PaymentResponseDTO;
import com.shanthigear.model.PaymentStatus;
import com.shanthigear.model.Vendor;
import com.shanthigear.model.VendorPayment;
import com.shanthigear.repository.VendorRepository;
import org.mapstruct.*;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

@Mapper(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE,
    uses = {DateMapper.class},
    imports = {PaymentStatus.class, LocalDateTime.class, LocalDate.class, System.class}
)
@SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection")
public class PaymentMapper {
    
    @Autowired
    protected VendorRepository vendorRepository;
    
    protected VendorRepository getVendorRepository() {
        return vendorRepository;
    }
    
    protected String getVendorNumber(String vendorNumber) {
        if (vendorNumber == null) {
            return null;
        }
        // Verify the vendor exists and return the vendorNumber as is
        vendorRepository.findByVendorNumber(vendorNumber)
            .orElseThrow(() -> new IllegalArgumentException("Vendor not found with vendor number: " + vendorNumber));
        return vendorNumber;
    }
    
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "vendorId", expression = "java(getVendorNumber(dto.getVendorId()))")
    @Mapping(target = "paymentReference", expression = "java(\"REF-\" + System.currentTimeMillis())")
    @Mapping(target = "status", expression = "java(PaymentStatus.PENDING)")
    @Mapping(target = "notificationSent", constant = "false")
    @Mapping(target = "createdAt", expression = "java(LocalDateTime.now())")
    @Mapping(target = "updatedAt", expression = "java(LocalDateTime.now())")
    @Mapping(target = "paymentDate", expression = "java(LocalDate.now())")
    @Mapping(target = "amount", source = "amount")
    @Mapping(target = "invoiceNumber", source = "invoiceNumber")
    @Mapping(target = "description", source = "description")
    @Mapping(target = "remarks", source = "description")
    @Mapping(target = "notes", source = "additionalNotes")
    public VendorPayment toEntity(PaymentRequestDTO dto) {
        if (dto == null) {
            return null;
        }

        VendorPayment.VendorPaymentBuilder vendorPayment = VendorPayment.builder();
        vendorPayment.id(null); // ID will be generated by the database
        vendorPayment.vendorId(getVendorNumber(dto.getVendorId()));
        vendorPayment.paymentReference("REF-" + System.currentTimeMillis());
        vendorPayment.status(PaymentStatus.PENDING);
        vendorPayment.notificationSent(false);
        vendorPayment.createdAt(LocalDateTime.now());
        vendorPayment.updatedAt(LocalDateTime.now());
        vendorPayment.paymentDate(LocalDate.now());
        vendorPayment.amount(dto.getAmount());
        vendorPayment.invoiceNumber(dto.getInvoiceNumber());
        vendorPayment.description(dto.getDescription());
        vendorPayment.remarks(dto.getDescription());
        vendorPayment.notes(dto.getAdditionalNotes());
        
        // Set vendor
        String vendorNumber = getVendorNumber(dto.getVendorId());
        Vendor vendor = vendorRepository.findByVendorNumber(vendorNumber)
            .orElseThrow(() -> new IllegalArgumentException("Vendor not found with vendor number: " + vendorNumber));
        vendorPayment.vendor(vendor);
        
        return vendorPayment.build();
    }

    /**
     * Converts a VendorPayment entity to a PaymentResponseDTO.
     */
    public PaymentResponseDTO toDto(VendorPayment payment) {
        if (payment == null) {
            return null;
        }

        PaymentResponseDTO.PaymentResponseDTOBuilder builder = PaymentResponseDTO.builder()
            .vendorId(payment.getVendorId())
            .vendorName(payment.getVendorName())
            .vendorEmail(payment.getVendorEmail())
            .amount(payment.getAmount())
            .paymentDate(payment.getPaymentDate())
            .bankAccount(payment.getBankAccount())
            .paymentReference(payment.getPaymentReference())
            .transactionId(payment.getTransactionId())
            .invoiceNumber(payment.getInvoiceNumber())
            .status(payment.getStatus() != null ? payment.getStatus().name() : "PENDING")
            .notificationSent(payment.isNotificationSent())
            .notes(payment.getNotes())
            .createdAt(payment.getCreatedAt())
            .updatedAt(payment.getUpdatedAt())
            .dueDate(payment.getDueDate());
            
        return builder.build();
    }

    /**
     * Updates an existing VendorPayment entity with values from the DTO.
     */
    public void updateEntityFromDto(PaymentRequestDTO dto, VendorPayment entity) {
        if (dto == null || entity == null) {
            return;
        }

        if (dto.getVendorId() != null) {
            String vendorNumber = getVendorNumber(dto.getVendorId());
            // Set the vendor relationship - this will automatically update the read-only vendorId field
            Vendor vendor = vendorRepository.findByVendorNumber(vendorNumber)
                .orElseThrow(() -> new IllegalArgumentException("Vendor not found with vendor number: " + vendorNumber));
            entity.setVendor(vendor);
        }
        if (dto.getAmount() != null) {
            entity.setAmount(dto.getAmount());
        }
        if (dto.getDescription() != null) {
            entity.setDescription(dto.getDescription());
        }
        if (dto.getInvoiceNumber() != null) {
            entity.setInvoiceNumber(dto.getInvoiceNumber());
        }
        if (dto.getAdditionalNotes() != null) {
            entity.setNotes(dto.getAdditionalNotes());
        }
        if (dto.getDueDate() != null) {
            try {
                entity.setDueDate(LocalDate.parse(dto.getDueDate()));
            } catch (Exception e) {
                // If date parsing fails, keep the existing due date
            }
        }
        
        // Update the updatedAt timestamp
        entity.setUpdatedAt(LocalDateTime.now());
    }

    /**
     * Generates a unique payment reference.
     * @return A unique payment reference string
     */
    public String generatePaymentReference() {
        return "PAY-" + UUID.randomUUID().toString().replace("-", "").substring(0, 12).toUpperCase();
    }
}
